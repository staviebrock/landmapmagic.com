<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LandMapMagic - Google Maps Selectable CLU</title>
    
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        #stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            min-width: 250px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        #stats-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
        }
        
        #stats-panel .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        #stats-panel .stat-label {
            font-weight: bold;
            color: #555;
        }
        
        #stats-panel .stat-value {
            color: #000;
        }
        
        #selected-list {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #selected-list h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #555;
        }
        
        .selected-item {
            padding: 8px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .selected-item:hover {
            background: #e5e5e5;
        }
        
        .remove-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .remove-btn:hover {
            background: #cc0000;
        }
        
        .clear-all-btn {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .clear-all-btn:hover {
            background: #0052a3;
        }
        
        .empty-message {
            color: #999;
            font-style: italic;
            font-size: 12px;
            text-align: center;
            padding: 20px 0;
        }
    </style>

    <!-- deck.gl dependencies for Google Maps integration -->
    <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/google-maps@^9.0.0/dist.min.js"></script>
</head>
<body>
    <div id="map"></div>
    
    <!-- Stats Panel -->
    <div id="stats-panel">
        <h3>ðŸ“Š Selected Fields</h3>
        
        <div class="stat-row">
            <span class="stat-label">Count:</span>
            <span class="stat-value" id="stat-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Acres:</span>
            <span class="stat-value" id="stat-total">0.00</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Average Acres:</span>
            <span class="stat-value" id="stat-average">0.00</span>
        </div>
        
        <div id="selected-list">
            <h4>Selected Polygons:</h4>
            <div id="selected-items">
                <div class="empty-message">Click polygons to select</div>
            </div>
        </div>
        
        <button class="clear-all-btn" onclick="clearAllSelections()">Clear All</button>
    </div>

    <!-- Google Maps API will be loaded dynamically -->

    <script>
        /**
         * LandMapMagic Google Maps Selectable Integration
         * 
         * Allows users to click to select/deselect CLU polygons
         * Displays statistics and list of selected polygons
         */

        // Access deck.gl classes from global namespace (loaded via script tags)
        const { GoogleMapsOverlay } = deck;
        const { MVTLayer } = deck;
        const { TextLayer } = deck;

        // Environment variables injected by Vite at build/serve time
        const GOOGLE_MAPS_KEY = '%VITE_GOOGLE_MAPS_API_KEY%';
        const LANDMAP_KEY = '%VITE_LANDMAP_API_KEY%';

        // Check if env vars are set (not placeholders)
        const googleApiKey = (GOOGLE_MAPS_KEY && !GOOGLE_MAPS_KEY.includes('VITE_')) ? GOOGLE_MAPS_KEY : '';
        const landmapApiKey = (LANDMAP_KEY && !LANDMAP_KEY.includes('VITE_')) ? LANDMAP_KEY : 'dev';

        if (!googleApiKey) {
            document.body.innerHTML = '<div style="padding:20px;color:red;">Missing VITE_GOOGLE_MAPS_API_KEY in .env.local</div>';
            throw new Error('Missing Google Maps API key');
        }

        // Your LandMapMagic API endpoint
        const BASE_URL = 'https://staging-api.landmapmagic.com';
        const TILE_URL = `${BASE_URL}/clu/{z}/{x}/{y}?key=${landmapApiKey}`;

        // Helper to format acres with 2 decimal places (no "ac" suffix)
        const fmtAcres = (v) => (v == null ? '' : v.toFixed(2));

        // ==================== SELECTION STATE ====================
        // Map to store selected polygons: key = unique ID, value = full feature object
        const selectedPolygons = new Map();
        
        // Map to store multiple ID formats for the same feature (for lookup during rendering)
        const selectedIdLookup = new Map();  // Maps any ID format -> primary ID
        
        // Reference to the overlay (set during initialization)
        let overlayInstance = null;
        
        // State version counter - increment to force deck.gl to re-render
        let stateVersion = 0;

        /**
         * Get consistent field ID from feature
         */
        function getFieldId(feature) {
            // Check feature.id first (this is where MVT features store their ID)
            if (feature.id !== undefined && feature.id !== null && feature.id !== '') {
                return String(feature.id);
            }
            
            // Fallback: check properties
            const props = feature.properties || {};
            const id = props.id || props.ID || props.objectid || props.OBJECTID || 
                       props.fid || props.FID || props.gid || props.GID;
            
            if (id !== undefined && id !== null && id !== '') {
                return String(id);
            }
            
            // Last resort: generate ID from properties
            return `field_${JSON.stringify(props)}`;
        }

        /**
         * Generate all possible ID formats for a feature
         */
        function getAllPossibleIds(feature) {
            const ids = [];
            
            // 1. Root level ID (from click event)
            if (feature.id !== undefined && feature.id !== null && feature.id !== '') {
                ids.push(String(feature.id));
            }
            
            // 2. Properties-based IDs
            const props = feature.properties || {};
            if (props.id !== undefined && props.id !== null && props.id !== '') {
                ids.push(String(props.id));
            }
            
            // 3. Fallback ID from properties (what rendering uses)
            const propsId = `field_${JSON.stringify(props)}`;
            ids.push(propsId);
            
            return ids;
        }

        /**
         * Toggle polygon selection
         */
        function togglePolygonSelection(feature) {
            const allIds = getAllPossibleIds(feature);
            const primaryId = allIds[0]; // Use first ID as primary
            
            console.log('ðŸ” All IDs for feature:', allIds);
            console.log('ðŸ” Acres:', feature.properties?.calcacres);
            
            if (selectedPolygons.has(primaryId)) {
                // Deselect - remove all ID mappings
                selectedPolygons.delete(primaryId);
                allIds.forEach(id => selectedIdLookup.delete(id));
                console.log('âŒ Deselected:', primaryId);
            } else {
                // Select - store feature and create mappings for all ID formats
                selectedPolygons.set(primaryId, feature);
                allIds.forEach(id => selectedIdLookup.set(id, primaryId));
                console.log('âœ… Selected:', primaryId, '| Total selected:', selectedPolygons.size);
                console.log('âœ… ID mappings created:', allIds);
            }
            
            // Increment state version to trigger deck.gl update
            stateVersion++;
            
            // Update UI and layer styling
            updateStatistics();
            updateSelectedList();
            refreshLayers();
        }

        /**
         * Calculate and update statistics
         */
        function updateStatistics() {
            const count = selectedPolygons.size;
            let totalAcres = 0;
            
            selectedPolygons.forEach((feature) => {
                const props = feature.properties || {};
                const acres = parseFloat(props.calcacres || props.CALCACRES || 0);
                totalAcres += acres;
            });
            
            const avgAcres = count > 0 ? totalAcres / count : 0;
            
            // Update UI
            document.getElementById('stat-count').textContent = count;
            document.getElementById('stat-total').textContent = totalAcres.toFixed(2);
            document.getElementById('stat-average').textContent = avgAcres.toFixed(2);
        }

        /**
         * Update the list of selected polygons in the UI
         */
        function updateSelectedList() {
            const container = document.getElementById('selected-items');
            
            if (selectedPolygons.size === 0) {
                container.innerHTML = '<div class="empty-message">Click polygons to select</div>';
                return;
            }
            
            let html = '';
            selectedPolygons.forEach((feature, fieldId) => {
                const props = feature.properties || {};
                const acres = props.calcacres || props.CALCACRES || 'N/A';
                const displayAcres = typeof acres === 'number' ? acres.toFixed(2) : acres;
                // Escape fieldId for safe use in HTML attribute
                const safeFieldId = String(fieldId).replace(/'/g, "\\'");
                
                html += `
                    <div class="selected-item">
                        <div>
                            <strong>ID:</strong> ${fieldId}<br>
                            <strong>Acres:</strong> ${displayAcres}
                        </div>
                        <button class="remove-btn" onclick="removeSelection('${safeFieldId}')">âœ•</button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        /**
         * Remove a single selection
         */
        function removeSelection(fieldId) {
            const feature = selectedPolygons.get(fieldId);
            if (feature) {
                const allIds = getAllPossibleIds(feature);
                allIds.forEach(id => selectedIdLookup.delete(id));
            }
            selectedPolygons.delete(fieldId);
            stateVersion++;
            updateStatistics();
            updateSelectedList();
            refreshLayers();
        }

        /**
         * Clear all selections
         */
        function clearAllSelections() {
            selectedPolygons.clear();
            selectedIdLookup.clear();
            stateVersion++;
            updateStatistics();
            updateSelectedList();
            refreshLayers();
        }

        /**
         * Refresh deck.gl layers to update styling
         */
        function refreshLayers() {
            if (overlayInstance) {
                console.log('ðŸ”„ Refreshing layers, stateVersion:', stateVersion, 'Selected:', selectedPolygons.size);
                console.log('ðŸ”„ Selected IDs:', Array.from(selectedPolygons.keys()));
                
                const newLayers = createLayers();
                overlayInstance.setProps({
                    layers: newLayers
                });
                
                // Force a redraw
                overlayInstance._deck.redraw();
                console.log('âœ… Layers refreshed and redraw triggered');
            }
        }

        /**
         * Create deck.gl layers with selection styling
         */
        function createLayers() {
            // Capture current stateVersion for updateTriggers
            const currentStateVersion = stateVersion;
            
            // Create a snapshot of the lookup map for this render
            const idLookupSnapshot = new Map(selectedIdLookup);
            
            console.log('ðŸŽ¨ Creating layers with lookup map size:', idLookupSnapshot.size);
            console.log('ðŸŽ¨ Lookup entries:', Array.from(idLookupSnapshot.entries()).slice(0, 5));
            
            // Track if styling functions are called
            let fillColorCallCount = 0;
            
            // 1) CLU Polygons (source-layer "clu")
            const cluPolygons = new MVTLayer({
                id: 'clu-polygons',  // Keep ID constant to prevent blinking
                data: TILE_URL,
                loadOptions: { 
                    mvt: { 
                        layers: ['clu']  // Only load 'clu' layer for polygons
                    } 
                },
                minZoom: 11,
                maxZoom: 15,
                filled: true,
                stroked: true,
                
                // Dynamic styling based on selection
                getFillColor: (feature) => {
                    const fieldId = getFieldId(feature);
                    const isSelected = idLookupSnapshot.has(fieldId);
                    
                    fillColorCallCount++;
                    if (fillColorCallCount <= 5) {  // Log first 5 calls
                        console.log(`ðŸŽ¨ getFillColor called: ID=${fieldId}, selected=${isSelected}`);
                    }
                    
                    if (isSelected) {
                        // Brighter green fill with more opacity
                        return [0, 255, 0, 80];  // Pure bright green with more opacity
                    }
                    return [0, 0, 0, 0];  // Transparent for unselected
                },
                
                getLineColor: (feature) => {
                    const fieldId = getFieldId(feature);
                    const isSelected = idLookupSnapshot.has(fieldId);
                    
                    if (isSelected) {
                        // SUPER BRIGHT LIME GREEN outline - very obvious!
                        return [0, 255, 0, 255];  // Pure lime green, full opacity
                    }
                    return [253, 224, 71, 230];  // Yellow for unselected
                },
                
                getLineWidth: (feature) => {
                    const fieldId = getFieldId(feature);
                    const isSelected = idLookupSnapshot.has(fieldId);
                    return isSelected ? 10 : 2;  // VERY thick border for selected
                },
                
                lineWidthMinPixels: 2,
                lineWidthMaxPixels: 15,  // Allow very thick lines
                pickable: true,
                
                onClick: (info) => {
                    if (!info.object) return;
                    togglePolygonSelection(info.object);
                },
                
                // Highlight on hover
                autoHighlight: true,
                highlightColor: [255, 255, 255, 100],  // White highlight on hover
                
                // Force deck.gl to re-evaluate styling when stateVersion changes
                updateTriggers: {
                    getFillColor: currentStateVersion,
                    getLineColor: currentStateVersion,
                    getLineWidth: currentStateVersion
                }
            });

            // 2) CLU Labels as TEXT (source-layer "clu_labels")
            const cluLabels = new MVTLayer({
                id: 'clu-labels',  // Keep ID constant to prevent blinking
                data: TILE_URL,
                binary: false,  // Required to use TextLayer in renderSubLayers
                loadOptions: { 
                    mvt: { 
                        layers: ['clu_labels']  // Only load 'clu_labels' layer for points
                    } 
                },
                minZoom: 13,  // Labels start at zoom 13
                maxZoom: 15,
                pickable: false,

                // Override renderSubLayers to turn point features into TextLayer
                renderSubLayers: (sublayerProps) => {
                    const { data } = sublayerProps;

                    if (!data || !data.length) {
                        return null;
                    }

                    return new TextLayer({
                        ...sublayerProps,
                        id: `${sublayerProps.id}-text`,
                        data,
                        // MVT points come through as GeoJSON features
                        getPosition: (f) => f.geometry.coordinates,
                        getText: (f) => {
                            const props = f.properties || {};
                            const acres = props.calcacres || props.CALCACRES;
                            return fmtAcres(acres);
                        },
                        getSize: 13,
                        sizeUnits: 'pixels',
                        getColor: [0, 0, 0, 255],  // Black text
                        getTextAnchor: 'middle',
                        getAlignmentBaseline: 'center',
                        
                        // White outline for contrast - requires SDF fonts
                        fontSettings: {
                            sdf: true,
                            fontSize: 64,
                            buffer: 4
                        },
                        outlineWidth: 6,  // White outline
                        outlineColor: [255, 255, 255, 255],
                        
                        // Font styling
                        fontFamily: 'Arial, sans-serif',
                        
                        pickable: false
                    });
                }
            });

            return [cluPolygons, cluLabels];
        }

        // Load Google Maps dynamically
        function loadGoogleMaps() {
            return new Promise((resolve, reject) => {
                if (typeof google !== 'undefined' && google.maps) {
                    resolve();
                    return;
                }

                window.initGoogleMapCallback = resolve;
                
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${googleApiKey}&callback=initGoogleMapCallback`;
                script.async = true;
                script.defer = true;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Initialize map
        async function initMap() {
            await loadGoogleMaps();

            // 1) Create Google Map
            const map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 41.878, lng: -93.097 }, // Iowa
                zoom: 13, // Start at zoom 13 so labels are visible
                mapId: 'DEMO_MAP_ID',
                mapTypeId: 'satellite'
            });

            // 2) Mount on Google Maps
            overlayInstance = new GoogleMapsOverlay({
                layers: createLayers()
            });
            overlayInstance.setMap(map);

            console.log('âœ… Map initialized with selectable CLU data');
        }

        // Auto-initialize on load
        initMap().catch((error) => {
            console.error('Failed to initialize map:', error);
            document.body.innerHTML = `<div style="padding:20px;color:red;">Failed to load map: ${error.message}</div>`;
        });
    </script>
</body>
</html>

