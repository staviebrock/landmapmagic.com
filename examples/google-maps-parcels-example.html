<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LandMapMagic - Google Maps + Parcels</title>
    
    <style>
        html, body, #map {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        .info-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            font-size: 13px;
            max-width: 300px;
            z-index: 100;
        }
        
        .info-box h3 {
            margin: 0 0 10px 0;
            font-size: 15px;
            color: #333;
        }
        
        .info-box p {
            margin: 5px 0;
            color: #666;
        }
        
        .info-box .tip {
            margin-top: 10px;
            padding: 8px;
            background: #f0f9ff;
            border-left: 3px solid #3b82f6;
            font-size: 12px;
            color: #1e40af;
        }
    </style>

    <!-- deck.gl dependencies for Google Maps integration -->
    <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/google-maps@^9.0.0/dist.min.js"></script>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-box">
        <h3>üèòÔ∏è Property Parcels</h3>
        <p><strong>Layer:</strong> Property Parcels (MVT)</p>
        <p><strong>Zoom:</strong> 14-17 (zoom in to see parcels)</p>
        <div class="tip">
            üí° Click on a parcel to view ownership and property details
        </div>
    </div>

    <!-- Google Maps API will be loaded dynamically -->

    <script>
        /**
         * LandMapMagic Google Maps + Property Parcels Integration
         * 
         * Demonstrates using property parcel data via MVT tiles
         * served directly from the Cloudflare Worker for optimal performance
         */

        // Access deck.gl classes from global namespace (loaded via script tags)
        const { GoogleMapsOverlay } = deck;
        const { MVTLayer } = deck;

        // Environment variables injected by Vite at build/serve time
        // To set up: Copy env.example to .env.local and add your API keys
        const GOOGLE_MAPS_KEY = '%VITE_GOOGLE_MAPS_API_KEY%';
        const LANDMAP_KEY = '%VITE_LAND_MAP_MAGIC_API_KEY%';
        const BASE_URL_ENV = '%VITE_LAND_MAP_MAGIC_API_URL%';

        // Check if env vars are set (not placeholders)
        const googleApiKey = (GOOGLE_MAPS_KEY && !GOOGLE_MAPS_KEY.includes('VITE_')) ? GOOGLE_MAPS_KEY : '';
        const landmapApiKey = (LANDMAP_KEY && !LANDMAP_KEY.includes('VITE_')) ? LANDMAP_KEY : 'dev';
        const BASE_URL = (BASE_URL_ENV && !BASE_URL_ENV.includes('VITE_')) ? BASE_URL_ENV : 'https://api.landmapmagic.com';
        
        // Note: 'dev' fallback only works in development environment
        // For staging/production, you must set VITE_LAND_MAP_MAGIC_API_KEY and VITE_LAND_MAP_MAGIC_API_URL in .env.local

        if (!googleApiKey) {
            document.body.innerHTML = '<div style="padding:20px;color:red;">Missing VITE_GOOGLE_MAPS_API_KEY in .env.local</div>';
            throw new Error('Missing Google Maps API key');
        }

        // Property Parcel MVT endpoint (served by Cloudflare Worker for optimal performance)
        // Note: This endpoint requires proper API key authentication
        // The .mvt extension is recommended (matches protomaps style: https://api.protomaps.com/tiles/v4/{z}/{x}/{y}.mvt)
        // The endpoint also works without .mvt, but including it is the preferred style
        const PARCEL_TILE_URL = `${BASE_URL}/parcels/tiles/{z}/{x}/{y}.mvt?key=${landmapApiKey}`;
        
        // Enhanced logging for debugging
        function logTileRequest(z, x, y) {
            const url = PARCEL_TILE_URL.replace('{z}', z).replace('{x}', x).replace('{y}', y);
            console.log(`[Parcels MVT] üó∫Ô∏è Requesting tile: ${z}/${x}/${y}`);
            console.log(`[Parcels MVT] üìç URL: ${url}`);
        }
        
        function logTileResponse(z, x, y, success, details = {}) {
            if (success) {
                console.log(`[Parcels MVT] ‚úÖ Tile loaded: ${z}/${x}/${y}`, details);
            } else {
                console.error(`[Parcels MVT] ‚ùå Tile failed: ${z}/${x}/${y}`, details);
            }
        }
        
        function logFeatureData(features) {
            if (!features || features.length === 0) {
                console.log('[Parcels MVT] üì¶ No features in tile');
                return;
            }
            console.log(`[Parcels MVT] üì¶ Tile contains ${features.length} parcel(s)`);
            features.forEach((feature, index) => {
                console.log(`[Parcels MVT]   Feature ${index + 1}:`, {
                    id: feature.id,
                    properties: feature.properties,
                    geometry: feature.geometry ? {
                        type: feature.geometry.type,
                        coordinates: feature.geometry.coordinates ? 
                            `${feature.geometry.coordinates.length} coordinate arrays` : 'no coordinates'
                    } : 'no geometry'
                });
            });
        }
        
        // Intercept fetch requests to log tile requests and responses
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && url.includes('/parcels/tiles/')) {
                // Extract tile coordinates from URL
                const match = url.match(/\/parcels\/tiles\/(\d+)\/(\d+)\/(\d+)/);
                if (match) {
                    const [, z, x, y] = match;
                    console.log(`[Parcels MVT] üåê Fetch request: ${z}/${x}/${y}`);
                    console.log(`[Parcels MVT] üì° Full URL: ${url}`);
                    
                    const startTime = Date.now();
                    return originalFetch.apply(this, args)
                        .then(response => {
                            const duration = Date.now() - startTime;
                            console.log(`[Parcels MVT] üì• Response received: ${z}/${x}/${y}`, {
                                status: response.status,
                                statusText: response.statusText,
                                ok: response.ok,
                                duration: `${duration}ms`,
                                contentType: response.headers.get('content-type'),
                                contentLength: response.headers.get('content-length'),
                                headers: Object.fromEntries(response.headers.entries())
                            });
                            
                            if (!response.ok) {
                                // Try to read error response
                                response.clone().text().then(text => {
                                    console.error(`[Parcels MVT] ‚ùå Error response body:`, text.substring(0, 500));
                                }).catch(e => {
                                    console.error(`[Parcels MVT] ‚ùå Could not read error response:`, e);
                                });
                            }
                            
                            return response;
                        })
                        .catch(error => {
                            const duration = Date.now() - startTime;
                            console.error(`[Parcels MVT] ‚ùå Fetch error for ${z}/${x}/${y}:`, {
                                error: error.message,
                                stack: error.stack,
                                duration: `${duration}ms`
                            });
                            throw error;
                        });
                }
            }
            return originalFetch.apply(this, args);
        };
        
        console.log('[Parcels MVT] üîß Fetch interceptor installed - all tile requests will be logged');

        // Color scheme for parcels
        const PARCEL_COLORS = {
            fill: [200, 220, 240, 120],      // Light blue with transparency
            stroke: [37, 99, 235, 255],      // Bright blue border
            highlight: [250, 204, 21, 200]   // Yellow highlight on hover
        };

        // Load Google Maps dynamically
        function loadGoogleMaps() {
            return new Promise((resolve, reject) => {
                if (typeof google !== 'undefined' && google.maps) {
                    resolve();
                    return;
                }

                window.initGoogleMapCallback = resolve;
                
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${googleApiKey}&callback=initGoogleMapCallback`;
                script.async = true;
                script.defer = true;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Format property info for display
        function formatParcelInfo(properties) {
            const owner = properties.owner || 'Unknown';
            const acreage = properties.acreage_calc || properties.acreage || 'Unknown';
            const marketValue = properties.mkt_val_tot || properties.market_value || 'Unknown';
            const parcelId = properties.parcel_id || properties.id || 'N/A';
            
            let info = `üè† Parcel Information\n\n`;
            info += `Owner: ${owner}\n`;
            info += `Acreage: ${typeof acreage === 'number' ? acreage.toFixed(2) : acreage} ac\n`;
            info += `Market Value: ${typeof marketValue === 'number' ? '$' + marketValue.toLocaleString() : marketValue}\n`;
            info += `Parcel ID: ${parcelId}`;
            
            return info;
        }

        // Initialize map
        async function initMap() {
            await loadGoogleMaps();

            // 1) Create Google Map centered on Des Moines, IA
            const map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 41.5868, lng: -93.6250 },  // Des Moines, IA
                zoom: 15,  // Start at zoom 15 to see parcels
                mapId: 'DEMO_MAP_ID',
                mapTypeId: 'satellite'
            });

            // Track hovered parcel - use object reference for efficient updates
            const hoverState = { parcelId: null, updateCounter: 0 };

            // Function to create the parcel layer with current hover state
            function createParcelLayer() {
                return new MVTLayer({
                    id: 'parcels',
                    data: PARCEL_TILE_URL,
                    minZoom: 14,  // Parcels available at zoom 14-17
                    maxZoom: 17,
                    
                    // Specify which source-layer to load from the MVT tile
                    // ReportAll MVT tiles contain a 'parcels' source-layer
                    loadOptions: {
                        mvt: {
                            layers: ['parcels']  // Only load the 'parcels' source-layer
                        }
                    },
                    
                    // Simple styling - let MVTLayer handle geometry types automatically
                    filled: true,
                    stroked: true,
                    
                    // Dynamic fill color based on hover state
                    getFillColor: (feature) => {
                        const parcelId = feature.properties?.parcel_id || feature.properties?.id || feature.properties?.robust_id;
                        return parcelId === hoverState.parcelId ? PARCEL_COLORS.highlight : PARCEL_COLORS.fill;
                    },
                    
                    getLineColor: PARCEL_COLORS.stroke,
                    getLineWidth: 2,
                    lineWidthMinPixels: 1,
                    lineWidthMaxPixels: 3,
                    
                    // Make pickable for click/hover
                    pickable: true,
                    autoHighlight: false,  // We'll handle highlighting manually
                    
                    // Use updateTriggers to efficiently update styling on hover
                    // The counter changes when hover changes, triggering a re-evaluation
                    updateTriggers: {
                        getFillColor: hoverState.updateCounter
                    },
                
                    // Log tile loading events
                // Note: onDataLoad may not be available in all deck.gl versions, but including it won't break
                onDataLoad: (data) => {
                    console.log('[Parcels MVT] üì• onDataLoad event:', {
                        type: data?.constructor?.name || typeof data,
                        hasFeatures: data?.length > 0 || (data?.features && data.features.length > 0),
                        dataKeys: data ? Object.keys(data) : [],
                        sampleFeature: data?.[0] || data?.features?.[0] || null
                    });
                    if (data?.features) {
                        logFeatureData(data.features);
                    } else if (Array.isArray(data)) {
                        logFeatureData(data);
                    }
                },
                
                // Log errors
                onError: (error) => {
                    console.error('[Parcels MVT] ‚ùå Layer error:', error);
                    console.error('[Parcels MVT] Error details:', {
                        message: error?.message,
                        stack: error?.stack,
                        name: error?.name,
                        cause: error?.cause
                    });
                },
                
                // Click handler with detailed logging
                onClick: (info) => {
                    console.log('[Parcels MVT] üñ±Ô∏è Click event:', {
                        hasObject: !!info.object,
                        coordinate: info.coordinate,
                        pixel: info.pixel,
                        index: info.index,
                        layer: info.layer
                    });
                    
                    if (!info.object) {
                        console.log('[Parcels MVT] ‚ö†Ô∏è Clicked but no object found');
                        return;
                    }
                    
                    const props = info.object.properties || {};
                    const geometry = info.object.geometry || {};
                    
                    console.log('[Parcels MVT] üìã Clicked parcel details:', {
                        properties: props,
                        geometryType: geometry.type,
                        hasCoordinates: !!geometry.coordinates,
                        allPropertyKeys: Object.keys(props),
                        propertyValues: Object.entries(props).reduce((acc, [key, value]) => {
                            acc[key] = typeof value === 'object' ? JSON.stringify(value).substring(0, 100) : value;
                            return acc;
                        }, {})
                    });
                    
                    // Log specific property values
                    console.log('[Parcels MVT] üè† Property details:', {
                        owner: props.owner,
                        parcel_id: props.parcel_id,
                        acreage_calc: props.acreage_calc,
                        mkt_val_tot: props.mkt_val_tot,
                        robust_id: props.robust_id,
                        addr_full: props.addr_full,
                        county_name: props.county_name,
                        state_abbr: props.state_abbr
                    });
                    
                    alert(formatParcelInfo(props));
                },
                
                // Hover handler - efficient update using updateTriggers
                onHover: (info) => {
                    const newHoveredId = info.object?.properties?.parcel_id || info.object?.properties?.id || info.object?.properties?.robust_id || null;
                    
                    if (newHoveredId !== hoverState.parcelId) {
                        if (newHoveredId) {
                            console.log('[Parcels MVT] üéØ Hovering over parcel:', {
                                parcel_id: newHoveredId,
                                properties: info.object?.properties || {},
                                coordinate: info.coordinate
                            });
                        } else {
                            console.log('[Parcels MVT] üëã Hover ended');
                        }
                        
                        // Update hover state and increment counter to trigger re-render
                        hoverState.parcelId = newHoveredId;
                        hoverState.updateCounter++;
                        
                        // Update overlay with new layer that has updated trigger
                        // This is efficient because deck.gl only re-evaluates getFillColor, not the entire layer
                        overlay.setProps({ 
                            layers: [createParcelLayer()]
                        });
                        
                        // Change cursor
                        document.body.style.cursor = hoverState.parcelId ? 'pointer' : 'default';
                    }
                }
            });
            }
            
            // Create initial parcel layer
            const parcelLayer = createParcelLayer();
            
            // Intercept tile requests by wrapping the data URL
            // Note: deck.gl doesn't expose tile request events directly, but we can log when tiles are requested
            console.log('[Parcels MVT] üîß Layer configuration:', {
                id: parcelLayer.id,
                data: PARCEL_TILE_URL,
                minZoom: 14,
                maxZoom: 17,
                pickable: true
            });

            // 3) Mount on Google Maps
            const overlay = new GoogleMapsOverlay({
                layers: [parcelLayer]
            });
            overlay.setMap(map);

            // Update info box with zoom level
            const infoBox = document.querySelector('.info-box p:nth-child(3)');
            map.addListener('zoom_changed', () => {
                const zoom = map.getZoom();
                if (infoBox) {
                    infoBox.innerHTML = `<strong>Zoom:</strong> ${zoom} ${zoom < 14 ? '(zoom in to see parcels)' : '‚úì'}`;
                }
                console.log(`[Parcels MVT] üîç Zoom changed to: ${zoom} ${zoom >= 14 && zoom <= 17 ? '(parcels visible)' : '(parcels not available at this zoom)'}`);
            });
            
            // Log map bounds changes to see what tiles should be loading
            map.addListener('bounds_changed', () => {
                const bounds = map.getBounds();
                const center = map.getCenter();
                const zoom = map.getZoom();
                
                if (zoom >= 14 && zoom <= 17) {
                    // Calculate approximate tile coordinates for center
                    const lat = center.lat();
                    const lng = center.lng();
                    const n = Math.pow(2, zoom);
                    const x = Math.floor((lng + 180) / 360 * n);
                    const latRad = lat * Math.PI / 180;
                    const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
                    
                    console.log(`[Parcels MVT] üó∫Ô∏è Map bounds changed:`, {
                        zoom: zoom,
                        center: { lat, lng },
                        bounds: {
                            north: bounds.getNorthEast().lat(),
                            south: bounds.getSouthWest().lat(),
                            east: bounds.getNorthEast().lng(),
                            west: bounds.getSouthWest().lng()
                        },
                        approximateCenterTile: `${zoom}/${x}/${y}`
                    });
                }
            });

            console.log('‚úÖ Map initialized with property parcel data');
            console.log('üìç Parcels will be visible at zoom level 14+');
            console.log('üîç Open browser console to see detailed tile loading and feature data');
            console.log('[Parcels MVT] üìä All tile requests, responses, and feature data will be logged here');
        }

        // Auto-initialize on load
        initMap().catch((error) => {
            console.error('Failed to initialize map:', error);
            document.body.innerHTML = `<div style="padding:20px;color:red;">Failed to load map: ${error.message}<br><br>Make sure you have set up your API keys in .env.local</div>`;
        });
    </script>
</body>
</html>

